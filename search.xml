<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CF1710C XOR Triangle]]></title>
    <url>%2F2022%2F07%2F31%2Fxortriangle%2F</url>
    <content type="text"><![CDATA[We are given a positive integer $n\ (0&lt;n&lt;2^{200\ 000})$ with its binary representation. Compute the number of triples $(a,b,c)$ with $0\leq a,b,c\leq n$ such that $a\oplus b,\ b\oplus c$, and $a\oplus c$ are the sides of a non-degenerate triangle. Here, $\oplus$ denotes the bitwise XOR operation. Three positive integers $x,y$, and $z$ are the sides of a non-degenerate triangle if and only if $x+y&gt;z,\ x+z&gt;y$, and $y+z&gt;x$. The key to this problem is to find a simple and intuitive set of constraints to describe the sides, with length $a\oplus b,\ b\oplus c$, and $a\oplus c$, of the above mentioned triangle. Let’s consider all numbers with their binary representation. Here, $a=(a_ta_{t-1}\cdots a_3a_2a_1a_0)_2$, $b=(b_ub_{u-1}\cdots b_3b_2b_1b_0)_2$, and $c=(c_vc_{v-1}\cdots c_3c_2c_1c_0)_2$. Define $d_{i_1,i_2,i_3}=(d_kd_{k-1}\cdots d_3d_2d_1d_0)_2$, where $m,n$, and $l$ can be either $0$ or $1$. Its $(j+1)$-th bit $d_j=1$ if $a_j=i_1,\ b_j=i_2$, and $c_j=i_3$. Otherwise, $d_j=0$. Therefore, $a,\ b$, and $c$ can be denoted as a=d_{100}+d_{101}+d_{110}+d_{111}\\ b=d_{010}+d_{110}+d_{011}+d_{111}\\ c=d_{001}+d_{011}+d_{101}+d_{111}And a\oplus b=d_{010}+d_{011}+d_{100}+d_{101}\\ b\oplus c=d_{001}+d_{010}+d_{101}+d_{110}\\ a\oplus c=d_{001}+d_{011}+d_{100}+d_{110}Also, a\oplus c+b\oplus c>a\oplus b\Leftrightarrow d_{001}+d_{110}>0\\ a\oplus b+b\oplus c>a\oplus c\Leftrightarrow d_{010}+d_{101}>0\\ a\oplus b+a\oplus c>b\oplus c\Leftrightarrow d_{100}+d_{011}>0 Using the sum of $d_{i_1,i_2,i_3}$ instead of xor operation, the problem can be simplified as: compute the number of triples $(a,b,c)$ such that d_{001}+d_{110}>0\\ d_{010}+d_{101}>0\\ d_{100}+d_{011}>0Note that each constraint can be satisfied if there exists at least $1$ binary bit that $a,b$, and $c$ has the right number respectively. For example, if $a_j=b_j=0,\ c_j=1$ or $a_j=b_j=1,\ c_j=0$, the first constraint is fulfilled. Therefore, we can use digital DP to solve this problem. Define $dp[n][i][j]$ as the number of triples while only the first $n$ bits were take into consideration. Note, however, that we consider those bits from upper to lower to ensure all numbers do not exceed $n$. $i$ function as a limitation of the upper bound. At some point if the current bit of $n$ is $1$, all numbers can be either $0$ or $1$ at this bit. But with $0$ be the current bit of $n$, there must be a previous position where a number is $0$ while $n$ is 1 for this number to take $1$ legally. $j$ represents whether each constraint is satisfied or not. As we’ve deduced from above, all constraints only needs to be fulfilled once. The overall time complexity is $O(2^9|n|)$, where $|n|$ is the total bits of the binary representation of $n$. 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 200000+50;constexpr auto MAXK = 1&lt;&lt;3;constexpr auto MOD = 998244353LL;char s[MAXN];long long D[MAXN][MAXK][MAXK]; //bit_rev upper_bound(next) conditonsigned main(void)&#123; std::cin&gt;&gt;s; int len=strlen(s),nlim,ncond,now; D[0][0][0] = 1LL; for(int i=0;i&lt;len;++i) for(int lim=0;lim&lt;MAXK;++lim) for(int cond=0;cond&lt;MAXK;++cond)&#123; D[i][lim][cond] %= MOD; now = s[i]-'0'; for(int nxt=0;nxt&lt;MAXK;++nxt)&#123; bool flag = false; for(int j=0;j&lt;3;++j) if(now==0 &amp;&amp; ((lim&gt;&gt;j)&amp;1) &lt; ((nxt&gt;&gt;j)&amp;1))&#123; flag=true; break; &#125; if(flag) continue; ncond = cond; nlim = lim; for(int j=0;j&lt;3;++j) if(now != ((nxt&gt;&gt;j)&amp;1)) nlim |= (1&lt;&lt;j); for(int j=0;j&lt;3;++j) if(nxt==(1&lt;&lt;j) || nxt==MAXK-1-(1&lt;&lt;j)) ncond |= (1&lt;&lt;j); D[i+1][nlim][ncond] += D[i][lim][cond]; &#125; &#125; long long ans = 0; for(int i=0;i&lt;MAXK;++i) ans += D[len][i][MAXK-1]; std::cout&lt;&lt;ans%MOD&lt;&lt;std::endl; return 0;&#125;]]></content>
      <categories>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>Digit DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ようこそ]]></title>
    <url>%2F2022%2F06%2F24%2FWelcome%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[APIO2008 Roads]]></title>
    <url>%2F2022%2F05%2F07%2Froads%2F</url>
    <content type="text"><![CDATA[We are given a graph $G$ contains $N$ vertices connected by $M$ edges, weighted and colored with either black or white. Find it’s minimum spanning tree that consists exactly $K$ black edges. Consider firstly that in some occasions there is no solution to this problem. $G$ is not connected. More than $K$ black edges are indispensable forming the tree. (They can be located using the Kruskal’s algorithm.) Otherwise, after selecting all indispensable edges, let the rest of them be divided by color and sorted by weight. Fill in black edges until the number reaches $K$, and select white edges to make it a tree eventually. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 20050;constexpr auto MAXM = 100050;//Mqsint up[MAXN],scale,sets;void Init(void)&#123; for(int i=1;i&lt;=scale;++i) up[i] = i; sets = scale;&#125;int Top(int a)&#123; return up[a]==a ? a : (up[a]=Top(up[a])); &#125;bool Merge(int a,int b)&#123; a = Top(a); b = Top(b); if(a==b) return false; up[a] = b; --sets; return true;&#125;struct Rd&#123; int u,v; bool mark; Rd()&#123;&#125; Rd(const int&amp; iu,const int&amp; iv):u(iu),v(iv) &#123; mark=false; &#125;&#125;;std::vector&lt;Rd&gt; pub,cem; signed main(void)&#123; int totRd,u,v,pubNum,type; scanf("%d%d%d", &amp;scale,&amp;totRd,&amp;pubNum); Init(); while(totRd--)&#123; scanf("%d%d%d", &amp;u,&amp;v,&amp;type); if(type)&#123; cem.push_back(Rd(u,v)); Merge(u,v); &#125; else pub.push_back(Rd(u,v)); &#125; int cnt = 0; for(auto&amp; it:pub) if(Merge(it.u,it.v))&#123; ++cnt; it.mark=true; &#125; if(cnt&gt;pubNum || sets&gt;1 || pub.size()&lt;pubNum)&#123; puts("no solution"); return 0; &#125; Init(); cnt=0; for(const auto&amp; it:pub) Merge(it.u,it.v); for(auto&amp; it:cem) if(Merge(it.u,it.v))&#123; ++cnt; it.mark=true; &#125; if(cnt &gt; scale-1-pubNum)&#123; puts("no solution"); return 0; &#125; Init(); cnt=pubNum; for(const auto&amp; it:pub) if(it.mark)&#123; Merge(it.u,it.v); --cnt; printf("%d %d 0\n", it.u,it.v); &#125; for(const auto&amp; it:cem) if(it.mark)&#123; Merge(it.u,it.v); printf("%d %d 1\n", it.u,it.v); &#125; for(const auto&amp; it:pub) if(!cnt) break; else if(Merge(it.u,it.v))&#123; --cnt; printf("%d %d 0\n", it.u,it.v); &#125; for(const auto&amp; it:cem) if(Merge(it.u,it.v)) printf("%d %d 1\n", it.u,it.v); assert(sets==1); return 0;&#125;]]></content>
      <categories>
        <category>Graph Theory</category>
      </categories>
      <tags>
        <tag>Spanning Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Virtual Tree]]></title>
    <url>%2F2022%2F02%2F17%2Fvirtualtree%2F</url>
    <content type="text"><![CDATA[Virtual Tree is a structure that consists of nodes, that are only important, derived from a tree $T$. There should be as few nodes as possible in order to expedite the dynamic programming process (or other related operations) of multiple times. To be specific, consider a tree $T$ that consists of $n$ nodes, where $n$ could be a very large number. Each time, we are given a set of nodes $S$ that need to be considered. A node $x$ is important and should be included in our virtual tree $T^\prime$ if either $x\in S$ $x$ is the lowest common ancestor(lca) of $u$ and $v$. ($u,v\in S$) Thus, let’s construct a virtual tree $T^\prime$ with the following procedure Search the entire tree $T$ in order to make following lca calculations possible. Plus, give each node an id that indicates its order during traversal. Create a stack $K$ that consists of the root initially, elements in $K$ denote a path on $T^\prime$ that needs to be constructed later. Eventually, an edge should be added between adjoining nodes in $K$, from the bottom(root) to the top. Consider each node $x(x\in S)$ in the increasing order of ID. It might create at most one additional important node. Add $x$ to the top of $K$. Empty the stack $K$ by adding edges between adjoining elements. To be specific in step 3, let $v$ and $u$ be the element on top of $K$ and the element below it respectively. A few different situations can occur in this step. If $x$ is a descendant of $v$, nothing needs to be done. If not, let $lca$ be the lca of $v$ and $x$. Add an edge $u\to v$ and pop $v$ out of $K$, until either $lca$ and $u$ refer to the same node, or $lca$ is a node on path $u\to v$. If $lca$ and $u$ refer to the same node, add an edge $u\to v$ and pop $v$ out of $K$. Otherwise, $lca$ is a node on path $u\to v$. Add an edge $lca\to v$, then replace the top element of $K$ with $lca$. In summary, node $lca$, the lowest common ancestor of $v$ and $x$, might be the ‘additional important node’ previously mentioned. It is possible that $lca$ is a node somewhere between nodes in $K$. Therefore, stack $K$ can serve as a structure that denotes a temporary path on $T^\prime$ which can be changed while adding a new node $x$, allowing us to place $lca$, which is an important node that was previously unknowable, into $T^\prime$. Note that it is crucial that we only free and reallocate memory blocks that immeiately needed, in order to avoid unnecessary calculations when $S$ is small.]]></content>
  </entry>
  <entry>
    <title><![CDATA[CTSC2018 Baoli Xiegua]]></title>
    <url>%2F2022%2F02%2F07%2Fbruteforce%2F</url>
    <content type="text"><![CDATA[We are given two weighted trees $T$ and $T^\prime$, both rooted and comprising $n$ vertices labeled from $1$ to $n$. The denotation $dep_i$ represents the length of the path from the root to vertex $i$ on $T$, and similarly, $dep_i^\prime$ signifies the length in tree $T^\prime$. The distance between vertices $u$ and $v$ is defined as: Dist(u,v)=dep_u+dep_v-dep_{LCA(u,v)}-dep_{LCA^\prime(u,v)}^\primeOur task is to calculate the maximum distance among all possible vertex pairs $(u,v)$, where $u$ and $v$ need not be distinct. The required calculation can be expressed as: ans=\frac12\max\left\{dis(u,v)+dep_u+dep_v-2dep_{LCA^\prime(u,v)}^\prime\right\}where $dis(u,v)$ is the length of the path from node $u$ to $v$ in tree $T$. First, let’s apply an edge divide-and-conquer on tree $T$. When edge $e=\{(u,v),w\}$ is selected, the subtree can be divided into 2 parts $S_1$ and $S_2$. Define $val_x$ as the sum of $dep_x$ and the length to $u$ for each vertex $x$. For pair $(u,v)$, although $dis(u,v)+dep_u+dep_v=val_u+val_v$ and can be easily calculated, $dep_{LCA^\prime(u,v)}^\prime$ still remains unknown as $LCA^\prime_{u,v}$ can vary. Here, we define $val_x$ as $x$’s contribution to tree $T$. An edge divide-and-conquer tree is needed as a structure that preserves the contribution of vertices pairs on $T$ later, allowing us to calculate the entire fomula by enumerating $LCA^\prime_{u,v}$ on $T^\prime$. To do this, we construct a binary tree $t_x$ initially consisting of only a root for each point $x$. Nodes on this tree with depth $i$ preserve the $val_x$ of the $i$-th time $x$ is visited during the previous edge divide-and-conquer process, and the relationship with father node indicates whether $x$ is in $S_1$ or $S_2$ at each time. In other words, $t_x$ can be constructed by adding a left child with $val_x$ after the leaf node for vertices in $S_1$ and a right child with $val_x$ after the leaf node for vertices in $S_2$ while applying edge divide-and-conquer. At any time there should be exactly one leaf node for each $t_x$. Eventually, $t_x$ should be a single path. Second, we enumerate all possible $lca=LCA^\prime(u,v)$ on $T^\prime$. With the value of $dep_{LCA^\prime(u,v)}^\prime$ fixed, the answer for this subtree is $ans=\frac12\left(\max\{val_u+val_v\}-2dep_{LCA^\prime(u,v)}^\prime\right)$. Here, $val_u$ and $val_v$ can be found as nodes that have the same depth on $t_u$ and $t_v$ respectively, their path to the root should share the same structure since $u$ and $v$ are always in the same set $S_i$ during previous division. This allows us to merge $t_u$ and $t_v$ using similar method as merging two segment trees. Similarly, the complxity altogether should not exceed $O(N\lg N)$. Each time while we merge nodes $x$ and $y$, $\max(val_x,val_y)$ should be the attribute $val$ of the merged node, and let $l,r$ be node $x,y$’s left child and right child respcetively, their attribute $val_l$ and $val_r$ indicates the contribution of $(u,v)$ that $LCA^\prime(u,v)=lca$ and have $val_u$ and $val_v$ calculated on $T$ previously. Therefore, the answer, to a specific node $lca$ on $T^\prime$, covering all pairs $(u,v)$ that $lca=LCA^\prime(u,v)$ can be calculated. Note, however, that this value is twice as what the problem asked. Finally, note that $Dist(x,x)=dep_x-dep_x^\prime$ might also be a possible answer. Overall time complexity for this approach is $O(N\lg N)$. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 366666+30&lt;&lt;1;constexpr auto MAXV = 2017011328+50;constexpr auto INT64MIN = (-1LL)*MAXN*MAXV;long long ans = INT64MIN,tmax;int totVert;struct Line&#123; int to; long long val; Line(const int&amp; ito=0,const long long&amp; iv=0):to(ito),val(iv) &#123;&#125;&#125;;//namespace publicstruct Node&#123; long long val; Node *ch[2]; Node()&#123; ch[0]=ch[1]=nullptr; val=INT64_MIN; &#125; Node(const long long&amp; iv):val(iv)&#123; ch[0]=ch[1]=nullptr; &#125;&#125;root[MAXN&gt;&gt;1],*leaf[MAXN&gt;&gt;1];void Merge(Node*&amp; a,Node*&amp; b)&#123; //a &lt;== b if(!b) return; if(!a)&#123; a=b; return; &#125; for(int i=0;i&lt;2;++i) if(a-&gt;ch[i] &amp;&amp; b-&gt;ch[i^1]) tmax = std::max(tmax, a-&gt;ch[i]-&gt;val+b-&gt;ch[i^1]-&gt;val); a-&gt;val = std::max(a-&gt;val,b-&gt;val); for(int i=0;i&lt;2;++i) Merge(a-&gt;ch[i],b-&gt;ch[i]);&#125;int up[MAXN&gt;&gt;1];int Top(int x)&#123; return up[x]==x?x:(up[x]=Top(up[x])); &#125;bool Merge(int a,int b)&#123; a=Top(a); b=Top(b); if(a==b) return false; up[b]=a; Node *ra=root+a,*rb=root+b; tmax=INT64MIN; Merge(ra,rb); return true;&#125;namespace t1&#123; std::vector&lt;Line&gt;G[MAXN&gt;&gt;1]; long long dep[MAXN]; struct Edge&#123; int to; long long val; bool ext; int nxt; Edge()&#123; nxt=0; ext=false; &#125; Edge(const int&amp; ito,const long long&amp; iv,const int&amp; iin):to(ito),val(iv),nxt(iin)&#123; ext=true; &#125; &#125;edge[MAXN&lt;&lt;1]; int fst[MAXN],totEdge=2,t1Vert; void Addedge(const int&amp; u,const int&amp; v,const int val=0)&#123; edge[totEdge]=Edge(v,val,fst[u]); fst[u]=totEdge++; edge[totEdge]=Edge(u,val,fst[v]); fst[v]=totEdge++; &#125; void Build(const int&amp; nowAt,const int&amp; fa=-1,const long long depth=0)&#123; dep[nowAt] = depth; int lst=0,k; for(const auto&amp; it:G[nowAt]) if(it.to!=fa)&#123; if(!lst)&#123; Addedge(nowAt,it.to,it.val); lst=nowAt; &#125; else&#123; k = ++t1Vert; Addedge(k,lst); Addedge(k,it.to,it.val); dep[lst=k] = depth; &#125; Build(it.to,nowAt,depth+it.val); &#125; &#125;//Transfer to binary tree void Log(const int&amp; nowAt,const long long len,const int&amp; pos,const int&amp; fa=-1)&#123; if(nowAt&lt;=totVert)&#123; leaf[nowAt]-&gt;ch[pos] = new Node(len+dep[nowAt]); leaf[nowAt] = leaf[nowAt]-&gt;ch[pos]; &#125; for(int i=fst[nowAt];i;i=edge[i].nxt)&#123; const Edge it=edge[i]; if(it.to==fa || !it.ext) continue; Log(it.to,len+it.val,pos,nowAt); &#125; &#125; int siz[MAXN],S,ct,ctsiz; void Find(const int&amp; nowAt,const int&amp; fa=-1)&#123; siz[nowAt]=1; int mx; for(int i=fst[nowAt];i;i=edge[i].nxt)&#123; const Edge it=edge[i]; if(it.to==fa || !it.ext) continue; Find(it.to, nowAt); siz[nowAt]+=siz[it.to]; mx = std::max(siz[it.to], S-siz[it.to]); if(mx &lt; ctsiz)&#123; ctsiz=mx; ct=i; &#125; &#125; &#125; void Divide(const int cent)&#123; if(!edge[cent].ext) return; edge[cent].ext = edge[cent^1].ext = false; int u=edge[cent].to,v=edge[cent^1].to; long long len=edge[cent].val; Log(u,0,0); Log(v,len,1); if(siz[u] &lt; siz[v]) std::swap(u,v); S-=siz[v]; ctsiz=INT_MAX; Find(u); Divide(ct); S=siz[v]; ctsiz=INT_MAX; Find(v); Divide(ct); &#125;&#125;namespace t2&#123; std::vector&lt;Line&gt;G[MAXN&gt;&gt;1]; long long dep[MAXN&gt;&gt;1]; void Dfs(const int&amp; lca,const int&amp; fa=-1,const long long depth=0)&#123; dep[lca]=depth; for(const auto&amp; it:G[lca]) if(it.to!=fa)&#123; Dfs(it.to,lca,depth+it.val); Merge(lca,it.to); ans = std::max(ans, tmax-(depth&lt;&lt;1)); &#125; &#125;&#125;signed main(void)&#123; int u,v; long long val; scanf("%d", &amp;totVert); for(int i=1;i&lt;totVert;++i)&#123; scanf("%d%d%lld",&amp;u,&amp;v,&amp;val); t1::G[u].emplace_back(v,val); t1::G[v].emplace_back(u,val); &#125; for(int i=1;i&lt;totVert;++i)&#123; scanf("%d%d%lld",&amp;u,&amp;v,&amp;val); t2::G[u].emplace_back(v,val); t2::G[v].emplace_back(u,val); &#125; t1::t1Vert = totVert; t1::Build(1); for(int i=0;i&lt;=totVert;++i) leaf[i] = root+i; t1::S=t1::t1Vert; t1::ctsiz=INT_MAX; t1::Find(1); t1::Divide(t1::ct); for(int i=1;i&lt;=totVert;++i) up[i]=i; t2::Dfs(1); ans&gt;&gt;=1; for(int i=1;i&lt;=totVert;++i) ans = std::max(ans, t1::dep[i]-t2::dep[i]); printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>Graph Theory</category>
      </categories>
      <tags>
        <tag>Divide-and-Conquer for Trees</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF566C Logistical Questions]]></title>
    <url>%2F2022%2F02%2F06%2Flogisticalquestions%2F</url>
    <content type="text"><![CDATA[https://codeforces.com/problemset/problem/566/C We are given a unrooted tree consisting of $n(n\leq200\ 000)$ vertices labelled from $1$ to $n$. The $i$-th vertex has a non-negative weight $w_i(0\leq w_i\leq10^8)$. Each edge has length $l_i(1\leq l_i\leq1000)$. Let $Dist(u,v)$ represent the sum of all edge’s length on path from $u$ to $v$. We need to select a root $c$ in order to minimize ans=\sum_{i=1}^nw_i\cdot \left(Dist(i,c)\right)^\frac32 First, consider randomly selecting a root $u$ which has $k$ children $v_1,\cdots,v_k$. Either $u$ is the desired root $c$, or $c$ is in one of its chilren $v_i$. Each time we need to come up with an idea to specify this particular $v_i$, so the possible root $c$ will be confined to nodes within the subtree $v_i$ (and node $u$). Second, it is important to recognize that $ans$ for root $u$ consists of $n$ parts, each of them resembles f(x)=w_x\cdot\left(Dist(x,u)\right)^\frac32 For any path $a\to b$ in the tree where $x\in a\to b$, $\left(Dist(x,u)\right)^\frac32$ should first decrease and then increase, having exactly $1$ local minimum. Formally, this makes it a convex function, and $f(x)$, as well as $ans_u$, share the same property. Third, by considering the gradient of $f(v_i)$ f(v_i)^\prime=\frac32w_{v_i}\cdot\left(Dist(x,v_i)\right)^\frac12we are able to judge whether it is worth searching for a better root $c$ in subtree $v_i$. Here, all nodes $x$ inside subtree $v_i$ needs to be take into our consideration. If the overall decline in moving towards $v_i$ is greater than the sum of inclination of all other children(considered informally), then it’s possible that node $c\in v_i$ may provide a better answer. Finally, by using centroid decomposition and selecting the tree’s center, which ensures that the sizes of all its subtrees will not exceed half of its own size, we can check the answers of all possible roots within $O(\log N)$ time complexity. The overall time complexity is therefore $O(N\log N)$. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 200000+50;long double ans=1e20; int ct;int totVertex,r[MAXN];struct Line&#123; int to; long double w; Line(const int&amp; ito,const long double&amp; iw):to(ito),w(iw) &#123;&#125;&#125;; std::vector&lt;Line&gt; G[MAXN];bool vis[MAXN];long double sum,pr[MAXN];long double Dfs(const int&amp; nowAt,const int&amp; fa,long double w)&#123; sum += r[nowAt]*pow(w,1.5); pr[nowAt] = 1.5*r[nowAt]*pow(w,0.5); for(const auto&amp; it:G[nowAt]) if(it.to!=fa) pr[nowAt] += Dfs(it.to,nowAt,w+it.w); return pr[nowAt];&#125;void Calc(const int&amp; nowAt)&#123; long double sumpr=0; sum=0; for(int i=0;i&lt;G[nowAt].size();++i) sumpr += Dfs(G[nowAt][i].to, nowAt, G[nowAt][i].w); if(sum &lt; ans)&#123; ans=sum; ct=nowAt; &#125; for(int i=0;i&lt;G[nowAt].size();++i) if(sumpr-2*pr[G[nowAt][i].to] &gt; 0) vis[G[nowAt][i].to] = true;&#125;int siz[MAXN],mx[MAXN],root,S;void Find(const int&amp; nowAt,const int&amp; fa=-1)&#123; siz[nowAt]=1; mx[nowAt]=0; for(const auto&amp; it:G[nowAt]) if(it.to!=fa &amp;&amp; !vis[it.to])&#123; Find(it.to,nowAt); siz[nowAt] += siz[it.to]; mx[nowAt] = std::max(mx[nowAt],siz[it.to]); &#125; mx[nowAt] = std::max(mx[nowAt], S-siz[nowAt]); if(mx[nowAt] &lt; mx[root]) root = nowAt;&#125;void Divide(const int&amp; nowAt)&#123; vis[nowAt] = true; Calc(nowAt); for(const auto&amp; it:G[nowAt]) if(!vis[it.to])&#123; mx[root=0]=INT_MAX; S=siz[it.to]; Find(it.to); Divide(root); &#125;&#125;signed main(void)&#123; scanf("%d", &amp;totVertex); for(int i=1;i&lt;=totVertex;++i) scanf("%d", r+i); for(int i=1,u,v,w;i&lt;totVertex;++i)&#123; scanf("%d%d%d", &amp;u,&amp;v,&amp;w); G[u].emplace_back(v,w); G[v].emplace_back(u,w); &#125; mx[root=0]=INT_MAX; S=totVertex; Find(1); Divide(root); printf("%d %.8Lf\n", ct,ans); return 0;&#125;]]></content>
      <categories>
        <category>Graph Theory</category>
      </categories>
      <tags>
        <tag>Divide-and-Conquer for Trees</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SNOI2017 Liwu]]></title>
    <url>%2F2021%2F06%2F23%2Fliwu%2F</url>
    <content type="text"><![CDATA[We are given a sequence $\{A_i\}$ with $A_1=1$. For each $n&gt;1$, $A_n=n^k+\sum_{i=1}^{n-1}A_i$. Calculate $A_n$ with $n$ and $k$ fixed. Let $T_i=\sum_{j=1}^iA_i$. Therefore, F_i=T_{i-1}+i^k\\ T_i=T_{i-1}+F_i=2T_{i-1}+i^kwhich can be denoted with the form of matrix multiplication as \begin{bmatrix} T_{i-1}\\ i^k\\ i^{k-1}\\ \vdots\\ i\\ 1 \end{bmatrix}\cdot\begin{bmatrix} 2& 1& 0& \cdots& 0& 0\\ 0& C_k^0& C_k^1& \cdots& C_k^{k-1}& C_k^k\\ 0& 0& C_{k-1}^0& \cdots& C_{k-1}^{k-2}& C_{k-1}^{k-1}\\ \vdots& \vdots& \vdots& \ddots& \vdots& \vdots\\ 0& 0& 0& \cdots& 1& 1\\ 0& 0& 0& \cdots& 0& 1 \end{bmatrix}=\begin{bmatrix} T_i\\ (i+1)^k\\ (i+1)^{k-1}\\ \vdots\\ i+1\\ 1 \end{bmatrix}In this way, the original sequence can be calculated using fast matrix exponentiation within $O(K^3\log N)$ time complexity. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;constexpr auto MAXK = 13;constexpr long long MOD = (long long)1e9+7LL;struct Matrix&#123; long long val[MAXK][MAXK]; Matrix()&#123; memset(val,0,sizeof(val)); &#125; Matrix&amp; Cls(void)&#123; memset(val,0,sizeof(val)); return *this; &#125; Matrix&amp; Def(void)&#123; Cls(); for(int i=0;i&lt;MAXK;i++) val[i][i] = 1LL; return *this; &#125; Matrix operator * (const Matrix&amp; times) const &#123; Matrix ans; for(int i=0;i&lt;MAXK;i++) for(int j=0;j&lt;MAXK;j++) for(int k=0;k&lt;MAXK;k++) (ans.val[i][j] += val[i][k]*times.val[k][j]) %= MOD; return ans; &#125; Matrix&amp; operator *= (const Matrix&amp; times)&#123; return *this = *this*times; &#125; Matrix operator ^ (long long b)&#123; Matrix ans,ts=*this; ans.Def(); for(;b;b&gt;&gt;=1,ts*=ts) if(b&amp;1) ans *= ts; return ans; &#125; Matrix&amp; operator ^= (long long b)&#123; return *this = *this^b; &#125;&#125;;signed main(void)&#123; int k; long long totNums,num[MAXK]=&#123;&#125;; Matrix A; std::cin&gt;&gt;totNums&gt;&gt;k; A.val[0][0] = 2LL; A.val[0][1] = 1LL; *num = 1LL; for(int i=0;i&lt;=k;i++)&#123; for(int j=k;j&gt;=0;--j) A.val[k+1-i][k+1-j] = num[j]; for(int j=k;j&gt;0;--j) (num[j] += num[j-1]) %= MOD; &#125; A ^= totNums; long long ans = 0LL; for(int i=1;i&lt;=k;i++) (ans += A.val[0][i]) %= MOD; std::cout&lt;&lt;ans&lt;&lt;std::endl; return 0;&#125;]]></content>
      <categories>
        <category>Basic Algorithms</category>
      </categories>
      <tags>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF888G XOR-MST]]></title>
    <url>%2F2021%2F06%2F23%2Fxormst%2F</url>
    <content type="text"><![CDATA[https://codeforces.com/problemset/problem/888/G?f0a28=1 We are given a complete undirected graph $G$ with $n\ (1\leq n\leq 200000)$ vertices. A number $a_i\ (0\leq a_i&lt; 2^{30})$ is assigned to each vertex, and the weight of an edge between vertices $i$ and $j$ is equal to $a_i\ \mathrm{xor}\ a_j$. Calculate the weight of the minimum spanning tree in this graph. In this special MST problem, Boruvka’s algorithm can provide us with new inspiration while other classic methods seems inefficient. To be specific, let’s define set $S_i$ consists of node $i$ only initially. Find the shortest path that connects $i\in S_i$ and $j\in S_j$ and merge sets $S_i$ and $S_i$ repeatedly. A MST can be found eventually. In this problem, construct a 01-trie $T$ with $a_i$, in which each path from root to leaf resembles a set of merged points. Note that all points with the same value is merged at first. Then search the trie and merge different sets at node $t$ that has both left child $u$ and right child $v$ by enumerate all number $a_i\in u$ and find $a_j\in v$ that generates the lowest weight $w=a_i\ \mathrm{xor}\ a_j$. Add the overall minimum $w$ to our answer each time. As that a vertex $a\in G$ will only be considered once while enumeration during nodes of it’s path on trie $T$, and that with $a_i$ fixed, it takes $O(\log N)$ to find $a_j$ each time. The overall time complexity should be $O(N\log^2 N)$. #include&lt;bits/stdc++.h&gt; constexpr auto MAXN = 200000+5; struct Node{ int bits,siz; Node *ch[2]; Node(void){ ch[0] = ch[1] = nullptr; siz = 0; } Node(const int&amp; ibits) : bits(ibits) { siz = 0; ch[0] = ch[1] = nullptr; } }*t0 = new Node(30); long long num[MAXN]; void Insert(const long long&amp; ins){ Node* nowAt = t0; long long pos; ++nowAt-&gt;siz; while(nowAt-&gt;bits&gt;=0){ pos = (ins&gt;&gt;nowAt-&gt;bits)&amp;1LL; if(nowAt-&gt;ch[pos] == nullptr) nowAt-&gt;ch[pos] = new Node(nowAt-&gt;bits-1); nowAt = nowAt-&gt;ch[pos]; ++nowAt-&gt;siz; } } long long Query(const long long&amp; val,Node* nowAt){ if(nowAt-&gt;bits&lt;0) return 0LL; long long pos = (val&gt;&gt;nowAt-&gt;bits)&amp;1LL; if(nowAt-&gt;ch[pos] != nullptr) return Query(val,nowAt-&gt;ch[pos]); else return (1LL&lt;&lt;nowAt-&gt;bits) + Query(val,nowAt-&gt;ch[pos^1]); } long long Dfs(Node* nowAt,const int&amp; siz = 0){ if(nowAt==nullptr || nowAt-&gt;bits&lt;0 || nowAt-&gt;siz&lt;=1) return 0LL; if(nowAt-&gt;ch[0]!=nullptr &amp;&amp; nowAt-&gt;ch[1]!=nullptr){ long long min = INT64_MAX; for(int i=0;i&lt;nowAt-&gt;ch[0]-&gt;siz;++i) min = std::min(min, Query(num[i+siz], nowAt-&gt;ch[1])); return min + (1LL&lt;&lt;nowAt-&gt;bits) + Dfs(nowAt-&gt;ch[0],siz) + Dfs(nowAt-&gt;ch[1],siz+nowAt-&gt;ch[0]-&gt;siz); } if(nowAt-&gt;ch[0] != nullptr) return Dfs(nowAt-&gt;ch[0],siz); if(nowAt-&gt;ch[1] != nullptr) return Dfs(nowAt-&gt;ch[1],siz); return 0LL; } signed main(void) { int totNums; std::cin&gt;&gt;totNums; for(int i=0;i&lt;totNums;i++) std::cin&gt;&gt;num[i]; std::sort(num,num+totNums); for(int i=0;i&lt;totNums;i++) Insert(num[i]); std::cout&lt;&lt;Dfs(t0)&lt;&lt;std::endl; return 0; }]]></content>
      <categories>
        <category>Graph Theory</category>
      </categories>
      <tags>
        <tag>Spanning Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[agc045c Range Set]]></title>
    <url>%2F2020%2F07%2F09%2Frangeset%2F</url>
    <content type="text"><![CDATA[https://atcoder.jp/contests/agc045/tasks/agc045_c We are given a string $x$ with length of $N$, and each char of its be 0 initially. There are 2 operations that can be applied to string $x$: Change $A$ continuous chars of $x$ to 0. Change $B$ continuous chars of $x$ to 1. Were those operations to be applied without any limitation, calculate the number of different strings that $x$ can be. Firstly, prove that the answer will not change if we swap $A$ and $B$. If using a sequence of operations can change $x$ into $x^\prime$, we can use the opposite of this sequence to change $x$ reversed to $x^\prime$ reversed, meaning that there is exactly $1$ correspondence for each $x^\prime$ in the reversed case. Therefore, swap the values of $A$ and $B$ will make no differences. Let’s make $A\leq B$. Secondly, consider the property of final string $x^\prime$. Were there be more than $B$ 1s continuously, $x^\prime$ can be constructed by the following way: starting from the front and tail of $x$, make $x$ and $x^\prime$ the same except this segment using greedy. As $A\leq B$, there should be a gap with length at least $B$, that ensures operation on 2 sides will not affect each other. Operation 2 can then fulfill this sequence with 1. Furthermore, if there do not exist such 1s in $x^{\prime\prime}$, it should be the result of a above mentioned string $x^\prime$, after operation 1 applied once, changing more than $A$ 1s into 0. Therefore, were we to judge whether a string $x^\prime$ is a possible result, turn all segments of 0s with length greater than $A$ into 1 and see if there is a segment of 1s with length greater than $B$. Conversely, all strings $x^\prime$ that are impossible to be constructed can be divided into several segments, that each one is either A segment of 0s with length less than $A$. A segment of 1s with length less that $B$, including several (possibly $0$) segments of 0s with length greater or equal to $A$. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;constexpr auto MOD = (long long)1e9+7;constexpr auto MAXN = 6000;long long Pow(long long a,long long b)&#123; long long ans = 1LL; for(;b;b&gt;&gt;=1,(a*=a)%=MOD) if(b&amp;1) (ans *= a) %= MOD; return ans;&#125;long long f[4][MAXN];long long g[MAXN][2];signed main(void)&#123; int len,a,b; long long ans=0; std::cin&gt;&gt;len&gt;&gt;a&gt;&gt;b; if(a &gt; b) std::swap(a,b); if(b&lt;2) goto OP; f[0][1] = 1LL; for(int i=2;i&lt;b;++i)&#123; f[0][i] = 1; for(int j=1;j&lt;i;++j) (f[0][i] += f[1][i-j]) %= MOD; for(int j=i-a;j&gt;=0;--j) (f[1][i] += f[0][j]) %= MOD; for(int j=1;j&lt;i;++j) (f[2][i] += f[3][j]) %= MOD; if(i &gt;= a) f[3][i] = 1; for(int j=i-a;j&gt;=0;--j) (f[3][i] += f[2][j]) %= MOD; &#125; for(int i=1;i&lt;=len;++i)&#123; if(i &lt; b) g[i][1] = f[0][i] + f[2][i]; for(int j=1; j&lt;b&amp;&amp;i-j&gt;0; ++j) (g[i][1] += g[i-j][0]*f[0][j]) %= MOD; if(i &lt; a) g[i][0] = 1LL; for(int j=1; j&lt;a&amp;&amp;i-j&gt;0; ++j) (g[i][0] += g[i-j][1]) %= MOD; &#125; ans = (g[len][0]+g[len][1]) % MOD; for(int i=1;i&lt;len;++i) (ans += g[i][0]*f[1][len-i]) %= MOD; OP: std::cout&lt;&lt; (Pow(2LL,len)-ans+MOD)%MOD &lt;&lt;std::endl; return 0;&#125;]]></content>
      <categories>
        <category>Basic Algorithms</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTS2019 Suiji Lifangti]]></title>
    <url>%2F2020%2F02%2F21%2Fsuiji%2F</url>
    <content type="text"><![CDATA[We are given a cube with the size of $n\times m\times l\ (1\leq n,m,l\leq 5,000,000)$, and with a number in each of its cells. A cell’s number is called extremely big if it is bigger than any number that is in a cell that has at least one dimension the same with this cell. Place $n\times m\times l$ numbers from $1$ to $n\times m\times l$ to all the cells with equal possibility, which is, each number has the same possibility to be allocated in any cells. Given that each number will only appear once, calculate the possibility that there be exactly $k\ (1\leq k\leq 100)$ extremely big numbers. Let $N=n\times m\times l$ and $R=\max(n,\ m\ l)$. Let’s call a allocation legal if there be exactly $k$ extreme numbers. Let’s denote that a cell $i$ is within $j$’s range if any dimension of $i$’s coordinates is the same with such dimension of extreme number $j$’s, and that the set of all cells with $j$’s range be $S_j$. Here, we have two facts noteworthy: An allocation with one extreme number $i$ within another extreme number $j$’s range is illegal. For any legal allocation, swap any of its 2 parallel plane will get a legal allocation, as for any extreme number $j$, $S_j$ do not change during such process. Let $G_k$ be the number(possibility) of allocations with exactly $k$ extreme numbers, and $F_k$ be the number(possibility) of allocations with at least $k$ extreme numbers. Therefore, $F_k$ should be the product of, methods to choose $g_i$ numbers where $g_i$ be the number of cells within $k$ extreme number’s range, and methods of position of $k$ numbers, and methods of allocation of $g_i$ numbers to $g_i$ cells, and methods of allocation of the rest of the numbers. Denote the first 3 variations as $a_i$, $b_i$, and $h_i$, therefore F_k=\binom N{g_i}b_ih_i(N-g_i)!There is, however, methods being counted multiple times in such form of definition, albeit it seems reasonable. For example, an allocation $A$ with 3 extreme numbers will be counted 3 times in $F_2$, as any 2 extreme numbers in $A$ has been considered as extreme numbers at least exists in $F_2$. In fact, for a allocation $A$ with $i$ extreme numbers, it has been counted $\binom ik$ in $F_k\ (k\leq i)$. Therefore, F_k=\sum_{i=k}^R\binom ikG_k And with polynomial inversion, we have G_k=\sum_{i=k}^R(-1)^{i-k}\binom ikF_k Let’s consider function $F_i$. As of $b_i$, any cell $N$ can be a possible extreme cell. After choosing one, all cells within its range cannot be extreme cell anymore, and turn the problem into a sub-problem with all 3 dimensions 1 smaller. b_i=\frac{\prod_{k=0}^{i-1}(n-k)(m-k)(l-k)}{i!}As of $g_i$, there be $(n-i)(m-i)(l-i)$ cells that are not within range after $i$ extreme cells chosen. g_i=N-(n-i)(m-i)(l-i)As of $h_i$. Let’s move all the extreme numbers to a corner using plane swapping mentioned above, and let them be increasing from inside to outside. Denote $a_i=(n-i)\times(m-i)\times(l-i)$. Consider the cell $u$ located at the corner, its number should be $u_v=nml$. The set of numbers within $u$’s, and other extreme numbers’, range is $T_u=S_u\cap(\bigcup_{0&lt;i&lt;u}S_i)$. The rest of the numbers $S_u-T_u$ can be placed without limits, as they do not affect other extreme numbers. We can discover that $|S_u-T_u|=a_{i-1}-a_i$. Provided the value of the extreme number, the rest of them have $P_{g_i-1}^{a_{i-1}-a_i-1}$ allocations. With this layer considered, the problem will turn into a sub-problem with all 3 dimensions 1 smaller. h_i=i!\prod_{j=1}^i\frac{(g_j-1)!}{g_{j-1}!}Finally, F_k=k!\cdot b_k\cdot\prod_{i=1}^k\frac1{g_j}\\ G_k=\sum_{i=k}^R(-1)^{i-k}\binom ik\cdot\prod_{j=0}^{i-1}(n-j)(m-j)(l-j)\cdot\prod_{j=1}^i\frac1{g_j}Overall time complexity is $O(T\cdot\min(n,m,l))$. Note, however, that the answer is $0$ if $k&gt;R$. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;template&lt;typename T&gt;T Max(const T&amp; a,const T&amp; b,const T&amp; c)&#123; return std::max(a,std::max(b,c)); &#125;template&lt;typename T&gt;T Min(const T&amp; a,const T&amp; b,const T&amp; c)&#123; return std::min(a,std::min(b,c)); &#125;constexpr auto MAXN = 5000000 + 50;constexpr auto MOD = 998244353LL;inline long long Pow(long long a,long long b)&#123; long long ans = 1LL; for(;b;b&gt;&gt;=1,(a*=a)%=MOD) if(b &amp; 1) (ans *= a) %= MOD; return ans;&#125;long long fact[MAXN],revfact[MAXN],g[MAXN],revg[MAXN],b[MAXN],revb[MAXN];inline long long C(long long n,long long r)&#123; return fact[n]*revfact[n-r]%MOD*revfact[r]%MOD;&#125;signed main(void)&#123; int totCases; long long n,m,l,t,R,k,N,delta,ans; //R_T *fact = 1LL; for(int i=1;i&lt;MAXN;++i) fact[i] = fact[i-1]*i%MOD; revfact[MAXN-1] = Pow(fact[MAXN-1],MOD-2); for(int i=MAXN-2;i&gt;=0;--i) revfact[i] = revfact[i+1]*(i+1) % MOD; scanf("%d", &amp;totCases); while(totCases--)&#123; scanf("%lld%lld%lld%lld", &amp;n,&amp;m,&amp;l,&amp;k); N = n*m%MOD*l % MOD; R = Min(n,m,l); if(R &lt; k)&#123; puts("0"); continue; &#125; *b = 1; for(int i=1;i&lt;=R;++i) b[i] = b[i-1]*(n-i+1)%MOD*(m-i+1)%MOD*(l-i+1)%MOD; *g = 1; *revg = 1; for(int i=1;i&lt;=R;++i) g[i] = ((N-(n-i)%MOD*(m-i)%MOD*(l-i)%MOD)%MOD+MOD) % MOD; for(int i=1;i&lt;=R;++i) revg[i] = revg[i-1] * g[i] % MOD; revg[R] = Pow(revg[R], MOD-2); for(int i=R;i&gt;0;--i) revg[i-1] = revg[i] * g[i] % MOD; //for(int i=1;i&lt;=R;++i)&#123; assert(revg[i] == Pow(g[i], MOD-2)); (g[i+1] *= g[i]) %= MOD; &#125; ans = 0; for(int i=k;i&lt;=R;++i)&#123; delta = (i-k&amp;1) ? MOD-1 : 1; delta = delta*C(i,k)%MOD*b[i]%MOD*revg[i]%MOD; (ans += delta) %= MOD; &#125; printf("%lld\n", (ans+MOD) % MOD); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Counting</category>
      </categories>
      <tags>
        <tag>Inversion Transformation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BJOI2019 Shanshu]]></title>
    <url>%2F2020%2F02%2F17%2Fshanshu%2F</url>
    <content type="text"><![CDATA[We are given a sequence $A$ consists of $k\ (1\leq k\leq 150,000)$ numbers initially. Each _delete operation_ removes all elements $a_i\in A$ that $a_i=k$. We can change the value of certain elements to ensure that sequence $A$ be empty after several delete operations. Calculate this minimum number that sequence $A$ can be deleted empty after such number of elements changed. Additionally, 2 types of modification might be added to sequence $A$: Change the value of $1$ certain element. Add $1$ or minus $1$ to all elements in $A$. Calculate the answer as well after each modifications. Firstly, let’s consider solving the problem without considering modifications. Imagine $n$ white blocks in a row which the $i$ -th block represents sequence $A$ when it has a length of $i$, after some delete operations probably. We are at block No.$n$ at the beginning. If there exists $a(a&gt;0)$ elements with value $n$, we shall move to block $n-a$ after the delete operation applied. As sequence $A$ will become $\varnothing$ in the end, we should go through all blocks from $n$ to $1$ during such process. Secondly, consider coloring several blocks black, which indicates that we can go pass this block while deleting. To be specific, if there be $k$ numbers with value $i$, we should color $[i-k+1,\ i]$ black. We can only delete elements from the tail with it’s block colored black, which means several changes might be needed. Since by using the optimal strategy, changing $1$ element adds $1$ black block, the answer should be the number of white blocks. Finally, with the modification operation being take under consideration, a segment tree is needed to preserve this sequence. Single element modification is needless to say, obvious, while global adding is equivalent to simply moving the query section. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;namespace SegTr&#123; struct Node&#123; int fr,to; int cnt,min,cntmin,dlt; Node *lft,*rgt; Node(const int&amp; ifr,const int&amp; ito) : fr(ifr),to(ito) &#123; dlt = 0; min = 0; cnt = cntmin = ito-ifr+1; lft = rgt = nullptr; &#125; Node&amp; Add(const int &amp;val)&#123; if(val)&#123; dlt += val; min += val; cnt = min==0 ? cntmin : 0; &#125; return *this; &#125; Node&amp; Push_Down(void)&#123; if(dlt &amp;&amp; lft!=nullptr)&#123; lft-&gt;Add(dlt); rgt-&gt;Add(dlt); dlt = 0; &#125; return *this; &#125; Node&amp; Update(void)&#123; if(lft != nullptr)&#123; cnt = lft-&gt;cnt + rgt-&gt;cnt; min = std::min(lft-&gt;min, rgt-&gt;min); cntmin = ((lft-&gt;min==min) ? lft-&gt;cntmin : 0) + ((rgt-&gt;min==min) ? rgt-&gt;cntmin : 0); &#125; return *this; &#125; &#125;*root; void Build(const int&amp; fr,const int&amp; to)&#123; Node *a,*b,*t; std::queue&lt;Node*&gt; que,add; for(int i=fr;i&lt;=to;++i)&#123; t = new Node(i,i); que.push(t); &#125; for(;que.size()&gt;=2;std::swap(que,add))&#123; while(que.size()&gt;=2)&#123; a = que.front(); que.pop(); b = que.front(); que.pop(); t = new Node(a-&gt;fr, b-&gt;to); t-&gt;lft = a; t-&gt;rgt = b; add.push(t); &#125; if(!que.empty())&#123; add.push(que.front()); que.pop(); &#125; &#125; root = que.front(); &#125; void Add(const int&amp; fr,const int&amp; to, const int&amp; val, Node* nowAt=root)&#123; if(to&lt;nowAt-&gt;fr || nowAt-&gt;to&lt;fr) return; nowAt-&gt;Push_Down(); if(fr&lt;=nowAt-&gt;fr &amp;&amp; nowAt-&gt;to&lt;=to) nowAt-&gt;Add(val); else&#123; Add(fr,to,val,nowAt-&gt;lft); Add(fr,to,val,nowAt-&gt;rgt); nowAt-&gt;Update(); &#125; &#125; void Add(const int&amp; pos, const int&amp; val)&#123; Add(pos,pos,val); &#125; int Query(const int&amp; fr,const int&amp; to, Node* nowAt=root)&#123; if(to&lt;nowAt-&gt;fr || nowAt-&gt;to&lt;fr) return 0; nowAt-&gt;Push_Down(); if(fr&lt;=nowAt-&gt;fr &amp;&amp; nowAt-&gt;to&lt;=to) return nowAt-&gt;cnt; else return Query(fr,to,nowAt-&gt;lft) + Query(fr,to,nowAt-&gt;rgt); &#125;&#125;; using namespace SegTr;constexpr auto MAXN = 150050&lt;&lt;1;constexpr auto MAXM = MAXN;int arr[MAXN+MAXM&lt;&lt;1];int val[MAXN],*cnt=arr+MAXN+MAXM;signed main(void)&#123; int totNums,totOptn; int dltQue=0, pos,cg,org; scanf("%d%d", &amp;totNums,&amp;totOptn); for(int i=0;i&lt;totNums;++i)&#123; scanf("%d", val+i); ++cnt[val[i]]; &#125; Build(-2*totOptn,totNums+2*totOptn); for(int i=1;i&lt;=totNums;++i) if(cnt[i] &gt; 0) Add(i-cnt[i]+1,i,1); while(totOptn--)&#123; scanf("%d%d", &amp;pos,&amp;cg); switch(pos)&#123; case 0: switch(cg)&#123; case 1: pos = totNums + dltQue; if(cnt[pos]) Add(pos-cnt[pos]+1, pos, -1); --dltQue; break; case -1: ++dltQue; pos = totNums + dltQue; if(cnt[pos]) Add(pos-cnt[pos]+1, pos, 1); break; default: assert(false); break; &#125; break; default: --pos; cg += dltQue; org = val[pos]; val[pos] = cg; if(org &lt;= totNums+dltQue) Add(org-cnt[org]+1, -1); --cnt[org]; ++cnt[cg]; if(cg &lt;= totNums+dltQue) Add(cg-cnt[cg]+1, 1); break; &#125; //Solve printf("%d\n", Query(1+dltQue, totNums+dltQue)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Data Structures</category>
      </categories>
      <tags>
        <tag>Segment Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Polynomials and the FFT]]></title>
    <url>%2F2019%2F01%2F04%2Ffft%2F</url>
    <content type="text"><![CDATA[The Fast Fourier Transform (FFT) is an efficient algorithm for computing the Discrete Fourier Transform (DFT) of a sequence, which is a mathematical transformation that is commonly used in signal processing to convert a signal from the time domain to the frequency domain. The basic idea behind the FFT is to divide the input sequence into smaller sub-sequences, and then recursively apply the DFT to these sub-sequences until the final DFT is computed, based on the divide-and-conquer strategy. We shall see as an example how FFT computes the convolution of input vectors, in which it shows its efficiency by reducing the computations required from $O(N^2)$ to $O(N\log N)$. PolynomialsFor polynomial multiplication, if $A(x)$ and $B(x)$ are polynomials of degree-bound $n$, their product $C(x)$ is a polynomial of degree-bound $(2n-1)$ such that $C(x)=A(x)B(x)$. That is, if $A(x)=\sum_{j=0}^{n-1}a_jx^j$ and $B(x)=\sum_{j=0}^{n-1}b_jx^j$, then $C(x)=\sum_{j=0}^{2n-2}c_jx^j$, where $c_j=\sum_{k=0}^ja_kb_{j-k}$. Representing polynomialsThe coefficient and point-value representations of polynomials are in a sense equivalent. By combining them we can multiply two degree-bound $n$ polynomials in $O(N\log N)$ time. Coefficient representationA coefficient representation of a polynomial A(x)=\sum_{j=0}^{n-1}a_jx^jof degree-bound $n$ is a vector of coefficients $a=(a_0,a_1,\cdots,a_{n-1})$. While adding two polynomials represented by the coefficient vectors takes $O(N)$ time, the straightforward method of multiplying two degree-bound $n$ polynomials $A(x)$ and $B(x)$ represented in coefficient form takes time $O(N^2)$. Point-value representationA point-value representation of a polynomial $A(x)$ of degree-bound $n$ is a set of $n$ point-value pairs \left\{(x_0,y_0),(x_1,y_1),\cdots,(x_{n-1},y_{n-1})\right\}such that all of the $x_k$ are distinct and $y_k=A(x_k)$. Computing a point-value representation for a polynomial given in coefficient form takes time $O(N^2)$. We shall see, however, if we select $n$ different points $x_k$ cleverly, so that $x_k=\omega_n^k$, we can accelerate this computation to run in time $O(N\log N)$. As well as interpolation-the inverse of evaluation-additionally. Given two input polynomials in their point-value representation form, the time to multiply them to obtain the point-value form of the result takes time $O(N)$. Multiplication of polynomials in coefficient formThe idea is to choose “complex roots of unity” as the evaluation points, allowing us to produce a point-value representation by taking the discrete Fourier transform (DFT) of a coefficient, as well as performing the inverse operation, interpolation, to produce a coefficient representation by taking the inverse DFT of point-value pairs, both within $O(N\log N)$ time. Therefore, since we can perform pointwise multiplication in time $O(N)$, the following procedure for multiplying polynomials given in coefficient form takes $O(N\log N)$ time. The DFT and FFTComplex roots of unityIf a complex number $\omega$ satisfies the equation ω^n=1then it is called an complex $n$th root of unity. There are exactly $n$ distinct complex $n$th roots of unity, which can be expressed as e^{\frac{2\pi ik}{n}}for $k=0,1,\cdots,n-1$. Among these roots, $e^{\frac{2\pi i}{n}}$ is called the principal $n$th complex root and is denoted by $\omega_n$. Cancellation lemma \omega_{dn}^{dk}=\omega_n^kfor any integers $n\ge0$, $k\ge0$, and $d&gt;0$. Proof: \omega_{dn}^{dk}=\left(e^{\frac{2\pi i}{dn}}\right)^{dk}=\left(e^{\frac{2\pi i}{n}}\right)^k=\omega_n^kAlso we have the following corollary \omega_n^{\frac{n}{2}}=\omega_2=-1Proof: \omega_n^{\frac{n}{2}}=\left(e^{\frac{2\pi i}{n}}\right)^{\frac{n}{2}}=\left(e^{\pi i}\right)=\omega_2Halving lemmaIf $n&gt;0$ is even, then the squares of the $n$ complex $n$th roots of unity are the $n/2$ complex $(n/2)$th roots of unity. Proof: \left(\omega_n^{k + \frac{n}{2}}\right)^2 = \omega_n^{2k + n} = \omega_n^{2k}\omega_n^n = \omega_n^{2k} = \left(\omega_n^k\right)^2Thus, $\omega_n^k$ and $\omega_n^{k+n/2}$ have the same square. This is essential to our divide-and-conquer approach since it guarantees that the recursive subproblems are only half as large. Summation lemmaFor any integer $n&gt;0$ and nonzero integer $k$ not divisible by $n$, \sum\limits_{j =0}^{n-1}{(w_n^k)^j} = 0Proof: \sum\limits_{j =0}^{n-1}{(w_n^k)^j} = \frac{(w_n^k)^n -1}{w_n^k -1} = \frac{(w_n^n)^k -1}{w_n^k -1} = \frac{(1)^k -1}{w_n^k -1}The DFTThe Fast Fourier Transform (FFT) is based on the divide-and-conquer strategy, which reduces the problem size by half at each step and then combines the results. Throughout this discussion, it is assumed that $n$ is a power of $2$. As mentioned earlier, computing the pointwise product $C(x) = A(x)B(x)$ requires $n$ evaluations of the product, resulting in a time complexity of $O(n^2)$. However, if certain special values are used, the time complexity can be reduced to $O(n\log n)$. These special values are a set of vectors (\omega_n^0,\omega_n^1,\omega_n^2,\cdots,\omega_n^{n-1})which yield the vector (y_0y^\prime_0,y_1y^\prime_1,y_2y^\prime_2,\cdots,y_{n-1}y^\prime_{n-1})where y_i=A(\omega_n^i)=\sum_{j=0}^{n-1}a_j\omega_n^{ij}\\ y_i^\prime = B(\omega_n^i)=\sum_{j=0}^{n-1}b_j\omega_n^{ij}The vector $y=(y_0,\cdots,y_{n-1})$ is the discrete Fourier transform (DFT) of the coefficient vector $a=(a_0,\cdots,a_{n-1})$. We also write $y=DFT_n(a)$. The FFTNow let’s consider how to calculate $y_i$. Suppose A(x)=\sum_{i=0}^{n-1}a_ix^iLet A_0(x)=\sum_{j=0}^{\frac{n}{2}-1}a_{2j}x^j\\ A_1(x)=\sum_{j=0}^{\frac{n}{2}-1}a_{2j+1}x^jtherefore A(x)=A_0(x^2)+xA_1(x^2)Substituting $x=\omega_n^k\,(k&lt;\frac n2)$ gives A(\omega_n^k)=A_0\left(\omega_\frac n2^k\right)+\omega_n^kA_1\left(\omega_\frac n2^k\right)Substituting $x=\omega_n^{k+\frac n2}\,(k&lt;\frac n2)$ gives A\left(\omega_n^{k+\frac n2}\right)=A_0\left(\omega_n^{2k}\omega_n^n\right)+\omega_n^k\omega_n^\frac n2A_1\left(\omega_n^{2k}\omega_n^n\right)\\ A\left(\omega_n^{k+\frac n2}\right)=A_0\left(\omega_\frac n2^k\right)-\omega_n^kA_1\left(\omega_\frac n2^k\right)These two formulas differ only in one sign, so after obtaining the pointvalue expression of $A_0$ and $A_1$, we can merge them to get $A$ in $O(N)$ time complexity. The pointvalue expression of $A_0$ and $A_1$ can be recursively calculated. If $A$ has only one term at some point, we can return directly. In this way, the time complexity of the entire fast Fourier transform process is $O(N\log N)$. Interpolation at the complex roots of unityAfter converting to the pointvalue representation, the pointvalue expression of polynomial $C$ can be computed in $O(N)$ time complexity. The Inversed Fast Fourier Transform is a method of interpolation that can convert the pointvalue representation back to the coefficient representation in $O(N\log N)$ time complexity. By writing the DFT as a matrix equation, we interpolate base on the existence of its inversed matrix $V_n^{-1}$ and the fact that the $(j,k)$ entry of $V_n^{-1}$ be $\omega_n^{-kj}/n$. \begin{bmatrix} y_0\\y_1\\\vdots\\y_{n-1} \end{bmatrix}=\begin{bmatrix} 1&1&1&\cdots&1\\ 1&\omega_n&\omega_n^{2}&\cdots&\omega_n^{n-1}\\ \vdots&\vdots&\vdots&\ddots&\vdots\\ 1&\omega_n^{n-1}&\omega_n^{2(n-1)}&\cdots&\omega_n^{(n-1)^2} \end{bmatrix}\cdot\begin{bmatrix} a_0\\a_1\\\vdots\\a_{n-1} \end{bmatrix}Uniqueness of an interpolation polynomialFor any set $\left\{(x_1,y_1),\cdots,(x_{n},y_{n})\right\}$ of $n$ point-value pairs such that all the $x_k$ values are distinct, there is a unique polynomial $A(x)$ of degree-bound $n$ such that $y_k=A(x_k)$. Proof. The equation $y_k=A(x_k)$ is equal to the matrix equation \begin{bmatrix} 1&x_1&x_1^2&\cdots&x_1^{n-1}\\ 1&x_2&x_2^2&\cdots&x_2^{n-1}\\ \vdots&\vdots&\vdots&\ddots&\vdots\\ 1&x_{n}&x_{n}^2&\cdots&x_{n}^{n-1} \end{bmatrix}\begin{bmatrix} a_1\\a_2\\\vdots\\a_{n} \end{bmatrix}=\begin{bmatrix} y_1\\y_2\\\vdots\\y_{n} \end{bmatrix}The matrix on the left is demoted $V(x_0,\cdots,x_{n-1})$ and is known as Vandermonde matrix. We shall see this matrix has determinant $\prod_{1\leq j&lt;k\leq n-1}(x_k-x_j)$ by induction. Let $n=2$ be the order of the Vandermonde matrix A=\begin{bmatrix} 1&x_1\\1&x_2\end{bmatrix}We have detA=x_2-x_1Now suppose the claim holds for $n-1$. Let $A$ be a Vandermonde matrix of order $n$. \begin{array}{lcl}detA&=&det\begin{bmatrix} 1&x_1&x_1^2&\cdots&x_1^{n-1}\\ 1&x_2&x_2^2&\cdots&x_2^{n-1}\\ \vdots&\vdots&\vdots&\ddots&\vdots\\ 1&x_n&x_n^2&\cdots&x_n^{n-1} \end{bmatrix}\\ &=&det\begin{bmatrix} 1&x_1&x_1^2&\cdots&x_1^{n-1}\\ 0&x_2-x_1&x_2^2-x_1^2&\cdots&x_2^{n-1}-x_1^{n-1}\\ \vdots&\vdots&\vdots&\ddots&\vdots\\ 0&x_n-x_1&x_n^2-x_1^2&\cdots&x_n^{n-1}-x_1^{n-1}\end{bmatrix}\\ &=&det\begin{bmatrix} x_2-x_1&x_2^2-x_1^2&\cdots&x_2^{n-1}-x_1^{n-1}\\ \vdots&\vdots&\ddots&\vdots\\ x_n-x_1&x_n^2-x_1^2&\cdots&x_n^{n-1}-x_1^{n-1}\end{bmatrix}\\ &=&det\begin{bmatrix} x_2-x_1&0&\cdots&0\\ 0&x_3-x_1&\cdots&0\\ \vdots&\vdots&\ddots&\vdots\\ 0&0&\cdots&x_n-x_1 \end{bmatrix}\cdot det\begin{bmatrix} 1&x_1+x_2&\cdots&\sum_{j=0}^{n-2}x_1^jx_2^{n-2-j}\\ 1&x_1+x_3&\cdots&\sum_{j=0}^{n-2}x_1^jx_3^{n-2-j}\\ \vdots&\vdots&\ddots&\vdots\\ 1&x_1+x_n&\cdots&\sum_{j=0}^{n-2}x_1^jx_n^{n-2-j}\\ \end{bmatrix}\\ &=&\prod_{j=2}^n(x_j-x_1)\,\cdot det\left(\begin{bmatrix} 1&x_2&x_2^2&\cdots&x_2^{n-2}\\ 1&x_3&x_3^2&\cdots&x_3^{n-2}\\ \vdots&\vdots&\vdots&\ddots&\vdots\\ 1&x_n&x_n^2&\cdots&x_n^{n-2} \end{bmatrix}\begin{bmatrix} 1&x_1&x_1^2&\cdots&x_1^{n-2}\\ 0&1&x_1&\cdots&x_1^{n-3}\\ \vdots&\vdots&\vdots&\ddots&\vdots\\ 0&0&0&\cdots&1\\ \end{bmatrix}\right)\\ &=&\prod_{j=2}^n(x_j-x_1)\,\cdot det\begin{bmatrix} 1&x_2&x_2^2&\cdots&x_2^{n-2}\\ 1&x_3&x_3^2&\cdots&x_3^{n-2}\\ \vdots&\vdots&\vdots&\ddots&\vdots\\ 1&x_n&x_n^2&\cdots&x_n^{n-2} \end{bmatrix} \end{array}and by the inductive hypothesis, we get detA=\prod_{j=2}^n(x_j-x_1)\prod_{2\leq j1)|\left((i\&1)1=0b\overline{0a_{m-1}a_{m-2}\cdots a_1}\\ (i\&1)1)|\left((i\&1)]]></content>
      <categories>
        <category>Polynomials</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[NOI2018 Nide Mingzi]]></title>
    <url>%2F2018%2F12%2F11%2Fnidemingzi%2F</url>
    <content type="text"><![CDATA[We are given a string $s$ with length $n\ (1\leq n\leq 5\times 10^5)$ and $q\ (1\leq q\leq 10^5)$ queries. For each query we are given a string $t$ and a segment $[l,r]$, calculate the number of different substrings of $t$ that are not substring of $s_{[l,r]}$. Overall $\sum |t|\leq 10^6$. Firstly, build a suffix tree $T$ for each query string $t$. If $s$ and $t$ share no common char, the answer should be the number of leaf nodes on $T$. Then, appoint a left endpoint $l$, endeavor to match as much chars as possible only considering $s_{[l\cdots]}$. If $r$ is the furthest we can go, mark all nodes on the path represents $t_{[l,r]}$ on $T$. The final answer is the different nodes unmarked. Secondly, while considering queries with $l=1$ and $r=|s|$, match $t$ on suffix tree $S$. Which is, appoint 2 pointers to nodes of $S$ and $T$ respectively, while $t_{[u,v]}$ matched, in order to move the start position to $u+1$, simply move both pointers to their suffix link will do the trick. Finally, in the general occasion, while considering $s_{[l\cdots r]}$, nodes cannot be visited unless they are located on a path that can be built using suffixes starting at $[l,r]$. For each node $x$ on the suffix tree, path $t_0\to x$ represents several suffixes’ prefix. As those suffixes are the suffixes represented by the leaf nodes in the subtree $x$, we can build a segment tree for each node $x$ that preserves the suffixes exist in subtree $x$. By constructing the segment trees of each nodes, using the method of persistent segment tree, we can solve this problem querying the possible suffix each time entering the next node. Overall time complexity is $O(N\log N+M\log M)$. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236#include&lt;bits/stdc++.h&gt;constexpr auto INT_32_MAX = 100000000;//SegmentTreenamespace SegTr&#123; const int range = (int)1e6+5; struct Node&#123; Node* lft,*rgt; int ID; Node(const int&amp; iID) : ID(iID) &#123; lft = rgt = nullptr; &#125; ~Node()&#123; if(lft!=nullptr) delete lft; if(rgt!=nullptr) delete rgt; &#125; &#125;; Node* Build(const int&amp; targ,const int&amp; ID)&#123; Node* ret = new Node(ID); int fr=0,to=range,mid; for(Node* nowAt=ret;fr&lt;to;)&#123; mid = fr+to&gt;&gt;1; if(targ&lt;=mid)&#123; nowAt-&gt;lft = new Node(ID); nowAt = nowAt-&gt;lft; to = mid; &#125; else&#123; nowAt-&gt;rgt = new Node(ID); nowAt = nowAt-&gt;rgt; fr = mid+1; &#125; &#125; return ret; &#125; Node* Merge(Node* a,Node* b,const int&amp; ID)&#123; if(a == nullptr) return b; if(b == nullptr) return a; Node* ret = new Node(ID); ret-&gt;lft = Merge(a-&gt;lft,b-&gt;lft,ID); ret-&gt;rgt = Merge(a-&gt;rgt,b-&gt;rgt,ID); return ret; &#125; void Attend(Node*&amp; a,Node* b,const int&amp; ID)&#123; if(a == nullptr)&#123; a = b; return; &#125; if(b == nullptr) return; if(a-&gt;ID != ID)&#123; Node* t = new Node(ID); t-&gt;lft = a-&gt;lft; t-&gt;rgt = a-&gt;rgt; a = t; &#125; Attend(a-&gt;lft,b-&gt;lft,ID); Attend(a-&gt;rgt,b-&gt;rgt,ID); &#125; bool Query(const int&amp; fr,const int&amp; to,Node* nowAt,const int nfr=0,const int nto=range)&#123; if(nowAt==nullptr || nfr&gt;nto || nto&lt;fr || to&lt;nfr) return false; if(fr&lt;=nfr &amp;&amp; nto&lt;=to) return true; if(Query(fr,to,nowAt-&gt;lft,nfr,nfr+nto&gt;&gt;1)) return true; if(Query(fr,to,nowAt-&gt;rgt,1+(nfr+nto&gt;&gt;1),nto)) return true; return false; &#125;&#125;;constexpr auto MAXN = (int)5e5+50;constexpr auto MAXM = (int)1e6+50;constexpr auto MAXK = 28;//Suffix Treestruct Node&#123; int start,len,totLen; SegTr::Node* root; Node* ch[MAXK],*link; Node()&#123; start = len = 0; link = nullptr; root = nullptr; memset(ch,0,sizeof(ch)); &#125; Node(const int&amp; istart,const int&amp; ilen) : start(istart),len(ilen) &#123; link = nullptr; root = nullptr; memset(ch,0,sizeof(ch)); &#125; ~Node()&#123; if(root != nullptr) delete root; for(auto&amp; it : ch) if(it != nullptr) delete it; &#125;&#125;*t0,*virt,*nowAt;int s[MAXN],remain,totLen;void Attend(const int&amp; add)&#123; s[totLen++] = add; ++remain; for(Node* last=virt,*t; remain;)&#123; while(nowAt-&gt;ch[s[totLen-remain]]!=nullptr &amp;&amp; remain&gt;nowAt-&gt;ch[s[totLen-remain]]-&gt;len)&#123; t = nowAt-&gt;ch[s[totLen-remain]]; remain -= t-&gt;len; nowAt = t; &#125; Node*&amp; v = nowAt-&gt;ch[s[totLen-remain]]; int endChar_v = v==nullptr ? MAXK-1 : s[v-&gt;start+remain-1]; if(v==nullptr || endChar_v==add)&#123; last-&gt;link = nowAt; last = nowAt; if(v == nullptr) v = new Node(totLen-remain,INT_32_MAX); else break; &#125; else &#123; Node* split = new Node(v-&gt;start, remain-1); v-&gt;start += remain-1; v-&gt;len -= remain-1; split-&gt;ch[endChar_v] = v; split-&gt;ch[add] = new Node(totLen-1, INT_32_MAX); last-&gt;link = v = split; last = split; &#125; if(nowAt == t0) --remain; else nowAt = nowAt-&gt;link; &#125;&#125;int dfs_clock;void Dfs1(Node* nowAt,const int&amp; sumLen=0)&#123; int ch = 0; const int dfn = ++dfs_clock; for(const auto&amp; it : nowAt-&gt;ch) if(it != nullptr) ++ch; if(ch == 0)&#123; nowAt-&gt;len = totLen - nowAt-&gt;start; nowAt-&gt;totLen = nowAt-&gt;len + sumLen; nowAt-&gt;root = SegTr::Build(totLen-nowAt-&gt;totLen,dfn); return; &#125; nowAt-&gt;totLen = sumLen+nowAt-&gt;len; SegTr::Node* ch1; ch = 0; for(const auto&amp; it : nowAt-&gt;ch) if(it != nullptr)&#123; Dfs1(it, nowAt-&gt;totLen); if(ch == 0) ch1 = it-&gt;root; else if(ch == 1) nowAt-&gt;root = SegTr::Merge(ch1, it-&gt;root,dfn); else SegTr::Attend(nowAt-&gt;root, it-&gt;root,dfn); ++ch; &#125;&#125;char ins[MAXM];int insarr[MAXM];namespace CNT&#123; struct Node&#123; int start,len,cov,totLen; Node* ch[MAXK],*link; Node()&#123; start = len = 0; link = nullptr; cov = -1; memset(ch,0,sizeof(ch)); &#125; Node(const int&amp; istart,const int&amp; ilen) : start(istart),len(ilen) &#123; link = nullptr; memset(ch,0,sizeof(ch)); cov = -1; &#125; ~Node()&#123; for(auto&amp; it : ch) if(it != nullptr) delete it; &#125; &#125;*t0,*virt,*nowAt; int s[MAXM],totLen,remain; int cov; void Attend(const int&amp; add)&#123; s[totLen++] = add; ++remain; for(Node* last=virt,*t; remain;)&#123; while(nowAt-&gt;ch[s[totLen-remain]]!=nullptr &amp;&amp; remain&gt;nowAt-&gt;ch[s[totLen-remain]]-&gt;len)&#123; t = nowAt-&gt;ch[s[totLen-remain]]; remain -= t-&gt;len; nowAt = t; &#125; Node*&amp; v = nowAt-&gt;ch[s[totLen-remain]]; int endChar_v = v==nullptr ? MAXK-1 : s[v-&gt;start+remain-1]; if(v==nullptr || endChar_v==add)&#123; last-&gt;link = nowAt; last = nowAt; if(v == nullptr) v = new Node(totLen-remain,INT_32_MAX); else break; &#125; else &#123; Node* split = new Node(v-&gt;start, remain-1); v-&gt;start += remain-1; v-&gt;len -= remain-1; split-&gt;ch[endChar_v] = v; split-&gt;ch[add] = new Node(totLen-1, INT_32_MAX); last-&gt;link = v = split; last = split; &#125; if(nowAt == t0) --remain; else nowAt = nowAt-&gt;link; &#125; &#125; long long cntans; void cntDfs(Node* nowAt)&#123; for(const auto&amp; it : nowAt-&gt;ch) if(it!=nullptr)&#123; cntDfs(it); if(it-&gt;cov != -1) nowAt-&gt;cov = nowAt-&gt;len; &#125; if(nowAt-&gt;cov &lt; 0) cntans += nowAt-&gt;len; else cntans += nowAt-&gt;len - nowAt-&gt;cov; &#125; void Dfs(Node* nowAt,const int&amp; sumLen=0)&#123; int ch = 0; for(const auto&amp; it : nowAt-&gt;ch) if(it != nullptr) ++ch; if(ch == 0)&#123; nowAt-&gt;len = totLen - nowAt-&gt;start; nowAt-&gt;totLen = nowAt-&gt;len + sumLen; return; &#125; nowAt-&gt;totLen = sumLen+nowAt-&gt;len; for(const auto&amp; it : nowAt-&gt;ch) if(it != nullptr) Dfs(it, nowAt-&gt;totLen); &#125; long long Count(void)&#123; cntans = 0LL; cntDfs(t0); return cntans; &#125; void Build(char* a)&#123; remain = totLen = 0; if(t0 != nullptr) delete t0; t0 = new Node(); nowAt = t0; if(virt==nullptr) virt = new Node(); for(;*a!='\0';++a) Attend(*a-'a'); Attend(MAXK-2); t0-&gt;link = t0; Dfs(t0); &#125;&#125;//Mainsigned main(void)&#123; int totQuery,fr,to; scanf("%s%d", ins,&amp;totQuery); t0 = new Node(); virt = new Node(); nowAt = t0; for(char* it=ins; *it!='\0'; ++it) Attend(*it-'a'); Attend(MAXK-2); t0-&gt;link = t0; Dfs1(t0); long long ans; int cov,inslen,totprevlen,delt; while(totQuery--)&#123; scanf("%s%d%d", ins,&amp;fr,&amp;to); --fr; --to; inslen = strlen(ins); CNT::Build(ins); for(int i=0;i&lt;inslen;i++) insarr[i] = ins[i]-'a'; nowAt = t0; cov = 0; CNT::nowAt = CNT::t0; CNT::cov = 0; totprevlen = 0; //nxtchar_pos for(int beg=0;beg&lt;inslen;++beg)&#123; if(totprevlen &lt; beg)&#123; totprevlen = beg; nowAt = t0; CNT::nowAt = CNT::t0; cov = CNT::cov = 0; &#125; nowAt = nowAt-&gt;link; cov = totprevlen-nowAt-&gt;totLen-beg; CNT::nowAt = CNT::nowAt-&gt;link; CNT::cov = totprevlen-CNT::nowAt-&gt;totLen-beg; while(cov&gt;0 &amp;&amp; cov&gt;=nowAt-&gt;ch[insarr[totprevlen-cov]]-&gt;len)&#123; delt = nowAt-&gt;ch[insarr[totprevlen-cov]]-&gt;len; nowAt = nowAt-&gt;ch[insarr[totprevlen-cov]]; cov -= delt; &#125; while(CNT::cov&gt;0 &amp;&amp; CNT::cov&gt;=CNT::nowAt-&gt;ch[insarr[totprevlen-CNT::cov]]-&gt;len)&#123; delt = CNT::nowAt-&gt;ch[insarr[totprevlen-CNT::cov]]-&gt;len; CNT::nowAt = CNT::nowAt-&gt;ch[insarr[totprevlen-CNT::cov]]; CNT::cov -= delt; &#125; while(totprevlen&lt;inslen &amp;&amp; (cov&gt;0 || nowAt-&gt;ch[insarr[totprevlen]]!=nullptr) &amp;&amp; SegTr::Query(fr,to-totprevlen+beg,nowAt-&gt;ch[insarr[totprevlen-cov]]-&gt;root) &amp;&amp; s[nowAt-&gt;ch[insarr[totprevlen-cov]]-&gt;start+cov]==insarr[totprevlen])&#123; ++cov; ++CNT::cov; ++totprevlen; while(cov&gt;0 &amp;&amp; cov&gt;=nowAt-&gt;ch[insarr[totprevlen-cov]]-&gt;len)&#123; delt = nowAt-&gt;ch[insarr[totprevlen-cov]]-&gt;len; nowAt = nowAt-&gt;ch[insarr[totprevlen-cov]]; cov -= delt; &#125; while(CNT::cov&gt;0 &amp;&amp; CNT::cov&gt;=CNT::nowAt-&gt;ch[insarr[totprevlen-CNT::cov]]-&gt;len)&#123; delt = CNT::nowAt-&gt;ch[insarr[totprevlen-CNT::cov]]-&gt;len; CNT::nowAt = CNT::nowAt-&gt;ch[insarr[totprevlen-CNT::cov]]; CNT::cov -= delt; &#125; &#125; if(CNT::cov == 0) CNT::nowAt-&gt;cov = CNT::nowAt-&gt;len; else CNT::nowAt-&gt;ch[insarr[totprevlen-CNT::cov]]-&gt;cov = std::max(CNT::nowAt-&gt;ch[insarr[totprevlen-CNT::cov]]-&gt;cov, CNT::cov); &#125; printf("%lld\n", CNT::Count()-inslen-1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Data Structures</category>
      </categories>
      <tags>
        <tag>Suffix Tree</tag>
      </tags>
  </entry>
</search>
